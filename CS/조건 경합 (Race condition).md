## 의미
- 두 개 이상의 연산이 서로의 실행 순서에 따라 다른 결과를 낼 수 있는 상황
- 특히 비동기 프로그래밍에서 흔히 발생
## 문제점
- **예측 불가능**
	- 코드의 실행 순서가 프로그램의 상태에 큰 영향을 미치므로 버그를 찾고 디버깅하기 어려워짐
- **데이터 손상**
	- 동일한 데이터에 대한 동시 업데이트로 인해 데이터가 손상될 수 있음
- **성능 문제**
	- Race condition을 해결하기 위해 추가적인 동기화 메커니즘을 도입하면 시스템의 성능이 저하될 수 있음
## 해결법
1. **동기화 메커니즘 사용**: 뮤텍스나 세마포어 같은 동기화 메커니즘을 사용하여 데이터에 안전하게 액세스
2. **Atomic Operation 사용**: 데이터를 업데이트하는 작업이 원자적(atomic)으로 수행되도록 함. 원자적 연산은 중간에 중단되지 않는 연산을 의미합니다.
3. **Promise Chaining**: JavaScript에서는 프로미스 체이닝을 사용하여 비동기 함수의 실행 순서를 보장
4. **async/await 사용**: JavaScript의 `async/await` 구문을 사용하여 비동기 코드를 동기적으로 작성하여 race condition을 방지

## 예시
```javascript
let value = 0;

function increment() {
  const newValue = value + 1;
  setTimeout(() => {
    value = newValue;
  }, 1000);
}

increment(); // 첫 번째 호출
increment(); // 두 번째 호출

```
- 위 코드에서 `increment` 함수는 `value`를 1만큼 증가시키지만 또한 비동기적으로 동작하여, 타이머가 1초 뒤에 실행됨
- 첫 번째 호출과 두 번째 호출 사이에 충분한 시간 간격이 없다면, 두 개의 타이머 콜백 모두 `value`의 초기 값을 0으로 읽게 되며, 결과적으로 둘 다 `value`를 1로 설정하려고 할 것임 (race condition)
	- 예상되는 결과는 `value`가 2가 되는 것이지만, 실제로는 `value`가 1이 됨